#!/usr/bin/env python3
"""
Test Protection System - Testa as corre√ß√µes de prote√ß√£o contra sobrescrita
Valida que os 343 produtos existentes est√£o protegidos
"""

import os
import sys
import json
import time
from pathlib import Path
from loguru import logger

# Adiciona o diret√≥rio atual ao path
sys.path.append(str(Path(__file__).parent))

from cloudflare_storage_fixed import CloudflareStorage
from top_products_aggregator import TopProductsAggregator
from backup_manager import BackupManager
from product_deduplication import ProductDeduplication

def test_hash_generation():
    """Testa gera√ß√£o de hash √∫nica e segura"""
    logger.info("üß™ Testando gera√ß√£o de hash seguro...")
    
    storage = CloudflareStorage(enable_protection=False)  # Desativa prote√ß√£o para teste r√°pido
    
    # Testa produtos similares
    test_products = [
        {"produto": "iPhone 16 128GB", "preco": 4500, "loja": "Loja A", "imagem_original": "url1"},
        {"produto": "iPhone 16 128GB", "preco": 4600, "loja": "Loja B", "imagem_original": "url2"},
        {"produto": "iPhone 16 - 128GB", "preco": 4500, "loja": "Loja A", "imagem_original": "url1"},
    ]
    
    generated_ids = []
    for i, product in enumerate(test_products):
        product_id = storage.generate_secure_product_id(
            product["produto"], 
            "test_source",
            product
        )
        generated_ids.append(product_id)
        logger.info(f"Produto {i+1}: {product['produto']} ‚Üí ID: {product_id}")
    
    # Verifica unicidade
    unique_ids = set(generated_ids)
    if len(unique_ids) == len(generated_ids):
        logger.success("‚úÖ IDs √∫nicos gerados com sucesso!")
        return True
    else:
        logger.error(f"‚ùå Colis√£o detectada! {len(generated_ids)} produtos geraram {len(unique_ids)} IDs √∫nicos")
        return False

def test_collision_protection():
    """Testa prote√ß√£o contra colis√£o durante armazenamento"""
    logger.info("üß™ Testando prote√ß√£o contra colis√£o...")
    
    storage = CloudflareStorage(enable_protection=True)
    
    # Simula produto j√° existente
    test_product = {
        "produto": "Produto Teste Colis√£o",
        "preco": 100.0,
        "categoria": "Teste",
        "imagem_original": "https://example.com/test.jpg",
        "descricao": "Produto para teste de colis√£o"
    }
    
    # Primeira inser√ß√£o
    logger.info("Inserindo produto pela primeira vez...")
    result1 = storage.store_product(test_product, "test_collision")
    
    if result1:
        logger.success("‚úÖ Primeira inser√ß√£o bem-sucedida")
    else:
        logger.error("‚ùå Falha na primeira inser√ß√£o")
        return False
    
    # Segunda inser√ß√£o (deve detectar produto existente)
    logger.info("Inserindo mesmo produto novamente (deve detectar exist√™ncia)...")
    test_product["descricao"] = "Descri√ß√£o atualizada para testar sobrescrita"
    result2 = storage.store_product(test_product, "test_collision")
    
    if result2:
        logger.success("‚úÖ Sistema detectou produto existente e atualizou")
        return True
    else:
        logger.error("‚ùå Falha na detec√ß√£o/atualiza√ß√£o")
        return False

def test_backup_system():
    """Testa sistema de backup"""
    logger.info("üß™ Testando sistema de backup...")
    
    backup_manager = BackupManager("test_backups")
    
    # Dados de teste
    test_products = [
        {
            "product_id": "test_001",
            "produto": "Produto Teste 1",
            "preco": 50.0,
            "categoria": "Teste",
            "source": "test"
        },
        {
            "product_id": "test_002", 
            "produto": "Produto Teste 2",
            "preco": 75.0,
            "categoria": "Teste",
            "source": "test"
        }
    ]
    
    # Testa backup di√°rio
    backup_file = backup_manager.create_daily_backup(test_products)
    
    if backup_file and os.path.exists(backup_file):
        logger.success(f"‚úÖ Backup criado com sucesso: {backup_file}")
        
        # Testa restaura√ß√£o
        restored_products = backup_manager.restore_from_backup(backup_file)
        if len(restored_products) == len(test_products):
            logger.success("‚úÖ Restaura√ß√£o de backup bem-sucedida")
            return True
        else:
            logger.error(f"‚ùå Falha na restaura√ß√£o: {len(restored_products)} != {len(test_products)}")
    else:
        logger.error("‚ùå Falha na cria√ß√£o do backup")
    
    return False

def test_deduplication():
    """Testa sistema de deduplica√ß√£o"""
    logger.info("üß™ Testando sistema de deduplica√ß√£o...")
    
    dedup = ProductDeduplication(similarity_threshold=0.8)
    
    # Produtos com duplicatas intencionais
    test_products = [
        {"produto": "iPhone 16 128GB Preto", "preco": 4500, "source": "loja_a"},
        {"produto": "iPhone 16 - 128GB - Preto", "preco": 4550, "source": "loja_b"},  # Duplicata
        {"produto": "Samsung Galaxy S24", "preco": 3500, "source": "loja_a"},
        {"produto": "Galaxy S24 Samsung", "preco": 3600, "source": "loja_c"},  # Duplicata
        {"produto": "MacBook Pro M3", "preco": 8000, "source": "loja_a"},  # √önico
    ]
    
    # Testa detec√ß√£o de duplicatas
    duplicate_groups = dedup.detect_duplicates(test_products)
    
    if len(duplicate_groups) >= 2:  # Espera pelo menos 2 grupos de duplicatas
        logger.success(f"‚úÖ Duplicatas detectadas: {len(duplicate_groups)} grupos")
        
        # Testa deduplica√ß√£o completa
        deduplicated, stats = dedup.deduplicate_products(test_products)
        
        expected_final = len(test_products) - stats['products_removed']
        if len(deduplicated) == expected_final:
            logger.success(f"‚úÖ Deduplica√ß√£o bem-sucedida: {len(test_products)} ‚Üí {len(deduplicated)} produtos")
            return True
        else:
            logger.error(f"‚ùå Falha na deduplica√ß√£o: {len(deduplicated)} != {expected_final}")
    else:
        logger.error(f"‚ùå Falha na detec√ß√£o: {len(duplicate_groups)} grupos encontrados")
    
    return False

def test_aggregator_integration():
    """Testa integra√ß√£o com o agregador principal"""
    logger.info("üß™ Testando integra√ß√£o com agregador...")
    
    try:
        aggregator = TopProductsAggregator()
        
        # Testa se usa sistema seguro de ID
        test_product = {
            "produto": "Produto Teste Agregador",
            "preco": 200.0,
            "categoria": "Teste",
            "source": "test_api",
            "imagem_original": "https://example.com/test.jpg"
        }
        
        # Testa padroniza√ß√£o
        standardized = aggregator.standardize_product(test_product)
        
        if standardized and 'product_id' in standardized:
            product_id = standardized['product_id']
            
            # Verifica se usa formato seguro
            if "_" in product_id and len(product_id) > 20:  # Formato: source_hash_timestamp
                logger.success(f"‚úÖ Agregador usando ID seguro: {product_id}")
                return True
            else:
                logger.error(f"‚ùå Formato de ID inseguro: {product_id}")
        else:
            logger.error("‚ùå Falha na padroniza√ß√£o do produto")
    
    except Exception as e:
        logger.error(f"‚ùå Erro no teste do agregador: {e}")
    
    return False

def test_full_protection():
    """Testa prote√ß√£o completa do sistema"""
    logger.info("üß™ Testando prote√ß√£o completa do sistema...")
    
    storage = CloudflareStorage(enable_protection=True)
    
    # Verifica status de prote√ß√£o
    protection_status = storage.get_protection_status()
    
    logger.info(f"Status de prote√ß√£o: {protection_status}")
    
    required_protections = ['protection_enabled', 'backup_system', 'deduplication_system']
    all_enabled = all(protection_status.get(key, False) for key in required_protections)
    
    if all_enabled:
        logger.success("‚úÖ Todos os sistemas de prote√ß√£o est√£o ativos")
        return True
    else:
        missing = [key for key in required_protections if not protection_status.get(key, False)]
        logger.error(f"‚ùå Prote√ß√µes ausentes: {missing}")
        return False

def run_all_tests():
    """Executa todos os testes de prote√ß√£o"""
    logger.info("üöÄ Iniciando bateria completa de testes de prote√ß√£o...")
    
    tests = [
        ("Gera√ß√£o de Hash Seguro", test_hash_generation),
        ("Prote√ß√£o contra Colis√£o", test_collision_protection), 
        ("Sistema de Backup", test_backup_system),
        ("Sistema de Deduplica√ß√£o", test_deduplication),
        ("Integra√ß√£o com Agregador", test_aggregator_integration),
        ("Prote√ß√£o Completa", test_full_protection),
    ]
    
    results = {}
    passed_count = 0
    
    for test_name, test_func in tests:
        logger.info(f"\n{'='*50}")
        logger.info(f"üß™ EXECUTANDO: {test_name}")
        logger.info(f"{'='*50}")
        
        try:
            start_time = time.time()
            result = test_func()
            duration = time.time() - start_time
            
            results[test_name] = {
                "passed": result,
                "duration": f"{duration:.2f}s"
            }
            
            if result:
                passed_count += 1
                logger.success(f"‚úÖ {test_name} PASSOU ({duration:.2f}s)")
            else:
                logger.error(f"‚ùå {test_name} FALHOU ({duration:.2f}s)")
                
        except Exception as e:
            logger.error(f"üí• {test_name} ERRO: {e}")
            results[test_name] = {
                "passed": False,
                "error": str(e),
                "duration": "N/A"
            }
    
    # Relat√≥rio final
    logger.info(f"\n{'='*60}")
    logger.info("üìã RELAT√ìRIO FINAL DOS TESTES")
    logger.info(f"{'='*60}")
    
    for test_name, result in results.items():
        status = "‚úÖ PASSOU" if result["passed"] else "‚ùå FALHOU"
        duration = result.get("duration", "N/A")
        logger.info(f"{status} | {test_name} ({duration})")
        
        if "error" in result:
            logger.error(f"     Erro: {result['error']}")
    
    success_rate = (passed_count / len(tests)) * 100
    logger.info(f"\nüéØ TAXA DE SUCESSO: {passed_count}/{len(tests)} ({success_rate:.1f}%)")
    
    if success_rate >= 80:
        logger.success("üéâ SISTEMA DE PROTE√á√ÉO APROVADO!")
        logger.info("‚úÖ Os 343 produtos existentes est√£o protegidos contra sobrescrita")
    else:
        logger.error("‚ö†Ô∏è SISTEMA DE PROTE√á√ÉO PRECISA DE CORRE√á√ïES")
        logger.warning("‚ùå Risco de perda de dados dos 343 produtos existentes")
    
    return success_rate >= 80

if __name__ == "__main__":
    # Configura logging para o teste
    logger.add("test_protection.log", rotation="10 MB", retention="7 days")
    
    logger.info("üîí INICIANDO TESTES DE PROTE√á√ÉO CONTRA SOBRESCRITA")
    logger.info("üéØ Objetivo: Proteger os 343 produtos existentes (294 + 49)")
    
    success = run_all_tests()
    
    if success:
        logger.success("üèÜ TESTES CONCLU√çDOS COM SUCESSO!")
        logger.info("üõ°Ô∏è Sistema pronto para novos scraps sem risco de sobrescrita")
    else:
        logger.error("üíÄ FALHAS DETECTADAS NOS TESTES!")
        logger.warning("üö® N√ÉO execute novos scraps at√© corrigir os problemas")
    
    sys.exit(0 if success else 1)